# 1. 코드 리뷰 (220725)

## (1) 두 개 뽑아서 더하기

- https://school.programmers.co.kr/learn/courses/30/lessons/68644

- 0번 인덱스가 더할 수 있는 인덱스 → 1, 2, 3, 4
- 1번 인덱스가 더할 수 있는 인덱스 → 2, 3, 4
- 2번 인덱스가 더할 수 있는 인덱스 → 3, 4
- 3번 인덱스가 더할 수 있는 인덱스 → 4
- 4번 인덱스가 더할 수 있는 인덱스 → X

```python
def solution(numbers):
    answer = []
    
    st = set()	# 중복 제거
    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            sum_ = numbers[i] + numbers[j]
            st.add(sum_)
            
	lst = list(st)
    answer = sorted(lst)
    
    return answer
```



## (2) OX 퀴즈

- https://www.acmicpc.net/problem/8958
- 연속된 O의 개수를 저장할 변수, 총점을 저장할 변수 2가지만 必

```python
import sys
sys.stdin = open('input.txt')

T = int(input())
O = 'O'
X = 'X'

for t in range(T):
    ox = input()
    
    count_o = 0
    score = 0
    
    for answer in ox:
        if answer == O:
            count_o += 1	# 연속된 O의 개수 1 증가
            score += count_o
        if answer == X:
            count_o = 0	# 연속된 O의 개수를 초기화
```



# 2. 시간 복잡도 & 빅오 표기법

## (1) 알고리즘의 시간 복잡도

1. 좋은 알고리즘?

   - 효율성이 좋은 알고리즘?

   - 성능이 좋은 알고리즘?

   - Input을 넣은 후 Output이 나오는 **시간이 짧은 알고리즘**!



2. 알고리즘 소요 시간 측정하기 (1)

   - 개개인의 컴퓨팅 환경에 따라, 같은 알고리즘이라도 측정 시간이 다르다.

   - 따라서, 환경에 영향을 받지 않는 **객관적 기준**이 필요하다.



3. 알고리즘 소요 시간 측정하기 (2)

   - 객관적 측정을 위해, **알고리즘 내부에서 기본연산이 몇 번 일어나는지** 살펴본다.

   - **기본연산**: 단위 시간 1이 소요되는 연산
     - ex) 할당, 산술, 비교, 반환…

   - **기본연산의 총 횟수 = 알고리즘의 소요 시간**

     ```python
     def count(word, char):
         total = 0
         for i in word:	# 기본연산의 총 횟수? → word의 길이만큼
             if i == char:	# 기본연산
                 total += 1	# 기본연산
                 
         return total    
     ```



4. **시간 복잡도** (Time Complexity)

- 문제를 해결하는데 걸리는 시간과 입력의 함수 관계
- 알고리즘의 수행 시간
  - 시간 복잡도가 높다 = 느린 알고리즘
  - 시간 복잡도가 낮다 = 빠른 알고리즘
- 성능을 측정할 때, 가장 기본연산이 일어나는 최악의 입력 n개가 들어온다고 가정한다.
  - 입력 n개에 따른 소요 시간을 수식으로 세울 수 있다.
  - 이때, 계수와 상수보단 차수를 더 중점으로 본다.



## (2) 빅오(Big-O) 표기법❣️

- **입력 n이 무한대**로 커진다고 가정하고, 시간 복잡도를 간단하게 표시하는 것

- **최고차항**만 남기고, 계수와 상수를 제거

  1. 6n + 4 → O(n)

  2. 3n + 2 → O(n)

  3. 3n<sup>2</sup> + 6n + 1 → O(n<sup>2</sup>)

- 매 입력에 따라 정확한 수식을 구하는 것은 불필요하며, 정확한 수치보다는 증가율에 초점을 맞춘다.

- 1과 2의 원래 소요시간은 2배가 차이나지만, 동일한 시간 복잡도를 가진다.

- O(1) < O(log n) < O(n) < O(n log n) < O(n<sup>2</sup>) < O(2<sup>n</sup>)

  ![post-thumbnail](https://velog.velcdn.com/images/kyunghwan1207/post/4b7f4cfe-3b66-4c16-9533-2e8643fa3c6a/big-o.jpeg)

- 문제 Set

  - O(1): 단순 산술 계산
    - a + b, 100 * 200

  - O(logN): 크기 N인 리스트를 반절씩 순회/탐색
    - **이진탐색**, 분할정복

  - O(N): 크기 N인 리스트를 순회
    - 리스트 순회
    - 1중 for문

  - O(NlogN): 크기 N인 리스트를 반절씩 탐색 × 순회
    - 높은 성능의 정렬
    - Merge/Quick/Heap Sort

  - O(N<sup>2</sup>): 크기 N인 2중 리스트를 순회
    - 2중 리스트 순회
    - 2중 for문

  - O(N<sup>3</sup>): 3중 리스트를 순회
    - 3중 리스트 순회
    - 3중 for문

  - O(2<sup>N</sup>): 크기 N 집합의 부분 집합

  - O(N!): 크기 N 리스트의 순열



## (3) 입력의 크기와 시간 복잡도

- (일반적 상황에서) 1초가 걸리는 입력의 크기
  - **O(N): 1억 (기준)**
  - O(NlogN): 500만
  - O(N<sup>2</sup>): 1만
  - O(N<sup>3</sup>): 500
  - O(2<sup>N</sup>): 20
  - O(N!): 10



- 【문제】 연속된 숫자들의 합 구하기

  - 자연수 N (1 ≤ N ≤ 1,000,000,000)

  - 1부터 N까지의 연속된 수를 모두 더한 값

  - 제한 시간 1초

    1. 1부터 N까지 일일이 더하기 → O(N), 시간 초과

    2. 가우스의 합 공식 `(n * (n + 1)) // 2` → O(1)



- **내장 함수, 메소드의 시간 복잡도**도 확인할 필요가 있다.
  - for문을 한 번만 썼다고 O(N)인 건 X
  - https://wiki.python.org/moin/TimeComplexity
  - 구현할 때에 너무 신경쓰지 말고, 통과하면 그냥 그대로 냅둬도 OK
  - 일단 문제를 푸는 데에 집중하고, 그 다음 수정을 해보자!



# 3. 배열 vs 연결 리스트

## (1) 배열 (Array)

> 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조

```c
int arr[5] = {70, 80, 20, 100, 90}	// C에서의 배열 선언
```

- 인덱스를 통해 데이터에 빠르게 접근
- 배열의 길이는 변경 불가 → 변경하고 싶다면 새로 생성
- 데이터 타입은 고정
- 불편하다!



## (2) 연결 리스트 (Linked List)

> 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조

- 맨 처음 노드부터 순차적으로 탐색
- 연결 리스트의 길이를 자유롭게 변경 가능 → 삽입, 삭제 편리
- 다양한 데이터 타입 저장
- 데이터가 메모리에 연속적으로 저장되지 X



# 4. 리스트

## (1) 파이썬의 리스트가 강력한 이유

> Life is too short, you need Python

- 배열의 장점 + 리스트의 장점
- 인덱스로 데이터에 접근 O (상수 시간)
- 길이 자유롭게 변경 O
- 다양한 데이터 타입 O



## (2) 리스트의 메소드

1. `.append(element)`
   - 리스트 맨 끝에 새로운 원소 삽입
   - 메모리 주소는 바로 접근할 수 O
   - 맨 끝에 바로 접근하는 것은 **O(1)**
   - 같은 원리로, 메모리 주소의 개수는 바로 알 수 있기 때문에, `len()`의 시간 복잡도도 **O(1)**
2. `.pop(index)`
   - 특정 인덱스에 있는 원소를 삭제 및 반환
   - 인덱스에 바로 접근하는 것은 **O(N)**
   - 만약 `.pop()`이라면 **O(1)**
3. `.count(element)`
   - 리스트에서 해당 원소의 개수를 반환
   - **O(N)**
4. `.index(element)`
   - 리스트가 처음으로 원소가 등장하는 인덱스 반환
   - 최악의 경우, 그 원소가 마지막에서 등장할 수 O
   - **O(N)**
5. `.sort()`
   - 리스트를 오름차순으로 정렬
   - `sorted(iterable)`와 `.sort()`의 시간 복잡도는 **O(NlogN)**
6. `.reverse()`
   - 리스트의 원소들의 순서를 거꾸로 뒤집기
   - `reversed(iterable)`와 `.reverse()`의 시간 복잡도는 **O(N)**



## (3) 리스트 관련 내장함수

1. `len()`: O(1)
2. `sum()`: O(N)
3. `max()`: O(N)
4. `min()`: O(N)
5. `sorted()`: O(NlogN)
6. `reversed()`: O(N)



## (4) List Comprehension

```python
nums = [i for in range(5)]	# [0, 1, 2, 3, 4]
odd_nums = [1 for in range(10) if i % 2 == 1]	# [1, 3, 5, 7, 9]
```

