import sys
input = sys.stdin.readline

'''
4 2
1 2 100 101
### 2

4 3
1 2 3 4
### 2

3 1
3 2 1
### 3

5 2
1 2 6 100 101
### 3

4 3
1 3 6 8
### 2

3 4
1 4 6
### 2

6 5
1 4 5 6 7 10
### 2

4 5
1 4 5 9
### 2

5 2
1 2 100 101 1000
# 3

5 3
1 2 3 4 1000
# 3
'''

N, L = map(int, input().split())        # 물이 새는 곳의 개수, 테이프의 길이
water = list(map(int, input().split())) # 물 새는 곳의 위치
cnt = 0

water.sort()

# 1. [1, 4, 5]에서 물이 새고, 테이프의 길이는 5라고 할 때
#   → 0.5 ~ 5.5의 범위를 테이프가 커버하므로, 1 ~ 5를 막으면 테이프의 길이가 5가 됨.
# 2. [1, 2, 3]에서 물이 새고, 테이프의 길이는 1이라고 할 때
#   → 0.5 ~ 1.5, 1.5 ~ 2.5, 2.5 ~ 3.5의 범위를 테이프가 커버하므로, 1을 막으면 테이프의 길이가 1이 되고 총 3개의 테이프가 필요함.
# 여기서 문제는 다음 위치까지의 거리 계산 시 +1을 고려해야 하는 것

tmp_len = 0 # 하나의 테이프를 사용한 길이
for i in range(N):
    # 1. 다음 위치까지의 거리 계산
    if i < N - 1:
        # 1.1. 다음 위치로 이동할 수 있는 경우
        dist = water[i + 1] - water[i]  # 현재 위치 ~ 다음 위치까지의 거리 (현재 위치 포함 X)
    else:
        # 1.2. 다음 위치로 이동할 수 없는 경우 (가장 마지막 위치)
        dist = 1    # 거리는 1 (현재 위치 포함 O)

    if tmp_len + dist < L:
        # 2.1. 현재까지 사용한 테이프 길이 + 다음 위치까지의 거리가 L - 1보다 작은 경우
        # L이 아닌 L - 1인 이유는 테이프 길이가 1인 경우 바로 테이프 개수를 증가시키기 위함
        tmp_len += dist  # 테이프를 다음 이동 거리만큼 사용
    else:
        # 2.2. 남은 테이프 길이가 다음 위치까지 이동하기에 충분하지 않은 경우
        cnt += 1    # 사용 테이프 개수 +1
        tmp_len = 0 # 테이프 사용 길이 초기화

if tmp_len > 0:
    # 3. 마지막 위치까지 테이프를 덮은 경우
    cnt += 1    # 사용 테이프 개수 +1

print(cnt)
