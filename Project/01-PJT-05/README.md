## 후기 작성

 금요일에 갑자기 머리도 아프고 감기와 몸살 기운이 있어 문제 푸는 게 살짝 힘들었다. 그럼에도 열심히 문제를 풀었는데, 시간 안에 문제를 다 풀지 못했다는 아쉬움에 그 날 밤 꿈에서도 백트래킹 문제를 열심히 풀었다... 꿈 꾸다가 깼을 때가 7시였는데, 9시에 일어날 때까지 그 꿈을 꿨으니 적어도 2시간 동안은 꿈 속에서 문제를 푼 것 같다. 아침에도 감기 증상이 안 나아져 있길래 병원을 갔더니 코로나 양성...🥲🥲🥲

 열 너무 많이 나고 힘들었지만 그래도 1일 1커밋을 지키기 위해 등산로 문제에 다시 도전했고, 결국 풀었다!!!! 사실 내가 문제를 잘못 이해했던 것이었지만, 그래도 스스로 풀었다는 사실이 너무너무 기쁘다. 요즘 매일매일이 성취감이 있어 즐거운 것 같다. 이 모의고사를 마지막으로 알고리즘 과정이 마무리 되었지만, 그래도 매일 알고리즘을 한 문제 이상 풀어야겠다... 반복만큼 강력한 실력 쌓는 방법은 없는 것 같다. 몸이 아픈데도 열심히 한 나에게 박수를 쳐주고 싶다.👏👏👏 



### 0. 반반

- 문자를 key로, 문자가 나온 횟수를 value로 가지는 딕셔너리 `dic`을 생성
- 딕셔너리의 길이가 2일 때 (= 나온 문자가 2 종류일 때)
  - 등장 횟수가 각각 2이면 Yes 출력
- 나머지 경우 No 출력



### 1. 모음이 보이지 않는 사람

- 문자가 a, e, i, o, u에 해당하지 않을 때만 문자를 `res`에 붙인다.



### 2. 퍼펙트 셔플

- 카드를 반으로 나누되, 카드가 홀수 개이면 먼저 놓는 쪽에 한 장이 더 들어가게 한다.

   ```python
    middle = N // 2 if N % 2 == 0 else N // 2 + 1
    cards_1 = total_cards[:middle]
    cards_2 = total_cards[middle:]
   ```

- 카드의 개수가 더 작거나 같은 `cards_2`를 기준으로 반복문을 돌리며, 새로운 배열 `res`에 `cards_1`과 `cards_2`의 요소들을 추가해 준다.

- `cards_1`의 길이가 더 길 경우, `res`에 `cards_1`의 마지막 요소를 추가해 준다.



### 3. Flatten

- `dump` 만큼 반복문을 돈다.
  - 최댓값은 -1 해주고, 최솟값은 +1을 해 준다.
  - 반복문을 한 번 돌 때마다 배열을 정렬해 준다.
- `res`에 max와 min 값의 차를 저장한다.



### 4. 창용 마을 무리의 개수

- 인접 리스트 방식으로 그래프를 표현하는`graph` 배열 생성
- `stack` 배열과 방문 여부를 체크하는 `visited` 배열 생성
- dfs 함수
  - 연결된 사람들을 모두 순회하며 방문 체크를 한다.
  - dfs 함수가 종료되면, `visited`는 연결된 사람들 모두에 대해 True가 된다.
- 사람 수만큼 반복하는 반복문
  - 방문하지 않았을 때 `dfs`를 호출
  - `dfs`가 호출된 수만큼 `cnt` 증가



### 5. 등산로 조성

- 손 디버깅

  ![img](https://cdn.discordapp.com/attachments/932205149127057421/1007907586588282900/image.png)

- 디버깅 하는데 값 확인할 변수도 너무 많아서 어지럽고, 백트래킹 문제라 손가락도 부러지는 줄 알았다...
- 그리고 아무리 봐도 맞게 짠 것 같은데 자꾸 답이 몇 개가 이상하게 나와서 2시간 반 동안 디버깅만 했는데도 결국 못 풀었는데, 오늘 (8/13) 몇 줄만 고쳐보니까 됐다..
  - 나는 자꾸 최소 봉우리 보다 같거나 낮은 지점에서 멈춰야 한다고 생각했는데 그냥 제일 긴 등산로를 출력하면 되는 문제였다...



- 2차원 리스트 `graph`와 크기가 같은 리스트 `visited`를 만든다.
- 최대 공사 가능 깊이는 K이지만, **단 한 곳**만 깎을 수 있기에, 산을 깎았는지의 여부를 저장할 `flag` 변수를 만든다.
- 제일 높은 곳에서 시작하기 위해, `graph` 내 가장 높은 지점 `max_h`를 찾아준다.
- 이차원 리스트를 순회
  - 제일 높은 곳에 도착하면, `road` 함수를 실행한다.
  - `road` 함수가 끝나면, 다른 시작점을 찾아 또 `road` 함수를 실행해야 하기 때문에, 기존 시작점에 대해 `visited` 배열을 초기화 해준다.
- `road` 함수
  - 현재 y 좌표, 현재 x 좌표, 현재 좌표의 산의 높이, 현재까지의 등산로 길이를 인자로 가진다.
  - visited\[y][x] = True로 해서 해당 좌표를 방문했음을 체크한다.
  - 상하좌우 방향으로 델타 탐색을 진행한다.
    - 조건 1. 인덱스 범위를 벗어나면 continue
    - 조건 2. 한 번 방문한 곳이면 continue
    - 산을 한 번 깎았으면 더 이상 산을 깎지 않는다.
      - 그러면 현재의 봉우리 높이와, 다음 좌표의 봉우리 높이를 비교하여, 다음 봉우리가 더 낮으면 다음 좌표로 이동한다.
      - 재귀가 끝나면 `visited[ny][nx] = False`로 해주어 뒤로 한 칸 다시 이동했음을 명시한다.
    - 산을 깎지 않았으면, 최대 K까지 산을 깎아본다.
      - 0부터 K까지 도는 반복문
        - 현재 봉우리의 높이와, 다음 좌표의 봉우리의 높이 - k를 비교하여, 다음 봉우리가 더 낮으면 다음 좌표로 이동한다.
        - k = 0인 경우, 산을 깎지 않았으므로 `flag = False`로 둔다.
        - 산이 깎인 만큼의 높이를 넘겨주며 재귀 호출한다.
        - 재귀가 끝나면 `visited[ny][nx] = False`로, `flag = False`로 되돌려 준다.
  - 델타 탐색이 끝나면, `ans` 변수에 최대 길이를 저장한다.